KIS: Software testing Instant Service for non-linear development on large software
================================

Abstract
--------------------------------
 While Linux kernel, which is an open source software of fairly large and complex scope, is developing very fast with the help of disttribtued version control system(DVCS)--git, current dsitributed development status gives unprecedented difficulties and pressure to the kernel software testing. We present a preliminary study of instant automated software testing for Linux kernel as a instant service and  design a prototype KIS. The goal of KIS is to check the building and running errors of Linux kernel in 1 hours after news commits from hundreds branchs and thousands of kernel developers. Preliminary work suggests it is technically feasible to give timely assitant to kernel developers daily work and reduce accumulated difficulties frome different kinds fo bugs in kernel development life.
  

1.Introduction
--------------------------------
1.1 Old history of tesing, 

Doing automated testing in a cloud instead of on individual developers’
machines increases the available compute power by orders
of magnitude. In the past, faster CPUs enabled increased levels
of interactivity in development, such as quick compile-retry cycles.
Cloud-based computation, offering vast numbers of fast CPUs with
plenty of memory, could engender a similar transformation, with
TaaS becoming a seamless extension of a developer’s environment.
If automated testing techniques can be adapted to scale up on cloud
infrastructures, they can yield the order-of-magnitude lower bug
density and higher programmer productivity we seek.

1.2 Crrent status of testing

Current development status of large open source software, specially linux kernel


1.3 example, the problems in developing linux kernel

1.4 breief summary 



2. Our Goal and Challengs
--------------------------------

2.1 Goal

2.2 Challenges


3. Priliminary Design and Implementation
--------------------------------
3.1 Arch and Components

3.2 Workflows

3.3 Optimizations

3.4 Priliminary Implementation

shell lang,  machine , hwo to run

4. Preliminary Results
--------------------------------

4.1 performance of building kernel

4.2 performance of running kernel

4.3 the number of error every day

4.4 the accurate degree of error source 


5. Discussion and Future Directions
--------------------------------


6. Reference
--------------------------------
